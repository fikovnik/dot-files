#+BEGIN_SRC emacs-lisp
;; ;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+END_SRC

;; ;; Resources:
;; ;; - https://github.com/hlissner/doom-emacs/blob/develop/modules
;; ;; - https://github.com/zaiste/.doom.d/
;; ;;   - the screencast guy
;; ;; - https://github.com/rschmukler/doom.d
;; ;; - https://github.com/ar1a/dotfiles/blob/master/emacs/.doom.d
;; ;; - https://github.com/forrestchang/.doom.d
;; ;; - and https://github.com/search?l=Emacs+Lisp&o=desc&q=%22.doom.d%22&s=stars&type=Repositories
;; ;; - https://tecosaur.github.io/emacs-config/config.html
;; TODO my terminal mode - make it a private package
;; (xclip-mode -1)

* Variables

#+BEGIN_SRC emacs-lisp
(defvar my-keys nil
  "The list of keys to be mapped as pairs of keySym and ascii code")

(defvar my-keys-debug nil
  "Toggle my-keys debugging")

(defvar my-st-dir "~/Projects/st"
  "The location of st terminal sources")
#+END_SRC

* Terminal keys
** ST terminal
Treat st terminal as xterm (cf. https://www.gnu.org/software/emacs/manual/html_node/elisp/Terminal_002dSpecific.html)

#+BEGIN_SRC emacs-lisp
(add-to-list 'term-file-aliases (quote ("st" . "xterm")))
#+END_SRC

** Input map in terminal

This section fixes key bindings in Emacs running in a terminal.

*** Overview

There are several problems in handling key events in the current terminals. For
example:
- it is not possible to use modifiers other than =C-= and =M-=,
- the =C-= modifier encodes lower or upper-case letters identically,
- special names for some ASCII characters collide with =C-= modified letters (e.g., a tab is =C-i=),
- there is no reliable way to use multiple modifier keys, other than, =M-S-=,
- some keys cannot be used with =C-= modifier, eg., =;=, =.=, =/=.

The reason for all of this is that there is no standard for these _corner_
cases. There has been a several proposals:
- [[http://www.leonerd.org.uk/hacks/fixterms/][Paul Evan's fixterms]]
- [[https://sw.kovidgoyal.net/kitty/protocol-extensions.html#extensions-to-the-xterm-protocol][Kitty extension to xterm protocol]]
- [[https://github.com/CyberShadow/term-keys][term-keys package]]
- XTerm's [[https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:formatOtherKeys][formatOtherKeys]] and [[https://invisible-island.net/xterm/manpage/xterm.html#VT100-Widget-Resources:modifyOtherKeys][modifyOtherKeys]] classes

I decided to use Paul's fixterm proposition (which is compatible with XTerm's
solution given =formatOtherKeys= is set to 1). It works as follows: for each
key combination that is not expressible in the current schema it will use the
following escape sequence:

#+BEGIN_SRC text :tangle no
ESC[<key>;<mod>u
#+END_SRC

where
- =key= is the ASCII decimal value of the key
- =mod= is 1 + bitmask encoding of the modifiers
  - =S-= = 1
  - =M-= = 2
  - =C-= = 4

For example, =C-;= sends =\e[59;5u=.

Xterm can do that as well with =formatOtherKeys:1=, which can be verified using:

#+BEGIN_SRC sh :tangle no
xterm -xrm '*modifyOtherKeys:1' -xrm '*formatOtherKeys:1' -e cat -v
#+END_SRC

- With =modifyOtherKeys:2= it can do even =C-m=, =C-j= and =C-i=:
  - =C-m= -- =109;5u=
  - =C-S-m= -- =77;6u=
  - =C-i= -- =105;5u=
  - =C-S-i= -- =73;6u=
  - =C-j= -- =106;5u=
  - =C-S-j= -- =74;5u=
  - =C-`= -- =96;5u=
  - =C-\= -- =92;5u=

For this to work, two things need to be updated:
1. the terminal emulator (st in my case)
2. the emacs's =input-decode-map=

**** Terminal - st

In [[https://st.suckless.org/][st]] (my terminal of choice), one has to modify two places:
1. =mappedkeys= variable in =config.h= which contains a list of
   custom-mapped keys:

   #+BEGIN_SRC c :tangle no
   XK_semicolon
   #+END_SRC

2. =keys= variable in =config.h= containing the actual mapping:

   #+BEGIN_SRC c :tangle no
   {XK_semicolon, ControlMask, "\033[59;5u", 0, 0}
   #+END_SRC

**** Emacs

In emacs we only need to add the corresponding binding into the
=input-decode-map=:

#+BEGIN_SRC emacs-lisp :tangle no
(define-key input-decode-map "\e[59;5u" (kbd "C-;"))
#+END_SRC

**** Notes about upper/lower keys binding

From Emacs _Key Sequence Input_:

#+BEGIN_QUOTE
If an input character is upper-case (or has the shift modifier) and has no
key binding, but its lower-case equivalent has one, then read-key-sequence'
converts the character to lower case. Note that lookup-key' does not perform
case conversion in this way.
#+END_QUOTE
**** Notes about [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Sequences.html#Key-Sequences][Key Sequences]] in Emacs
- The Emacs Lisp representation for a key sequence is a string or vector.
- The =kbd= macro returns a representation of a key sequence using some sort of
  translation.
- It is also possible to bind keys using a vector like =[C-S-M]= which will
  create a =<C-M>= binding, a different from =C-S-M=.
*** Configuration
**** Default keys

#+BEGIN_SRC emacs-lisp
(setq my-keys-debug nil
      my-keys '((?\; "XK_semicolon"    ("C" "C-M"))
                (?:  "XK_colon"        ("C-S" "C-M-S"))
                (?'  "XK_apostrophe"   ("C" "C-M"))
                (?\" "XK_quotedbl"     ("C-S" "C-M-S"))
                (?.  "XK_period"       ("C" "C-M"))
                (?,  "XK_comma"        ("C" "C-M"))
                (?=  "XK_equal"        ("C" "C-M"))
                (?<  "XK_less"         ("C-S" "C-M-S"))
                (?>  "XK_greater"      ("C-S" "C-M-S"))
                (??  "XK_question"     ("C-S" "C-M-S"))
                (?/  "XK_slash"        ("C" "C-M"))
                (?\\ "XK_backslash"    ("C" "C-M"))
                (?|  "XK_bar"          ("C-S" "C-M-S"))
                (?~  "XK_asciitilde"   ("C-S" "C-M-S"))
                (?`  "XK_grave"        ("C" "C-S"))
                (?{  "XK_braceleft"    ("C-S" "C-M-S"))
                (?}  "XK_braceright"   ("C-S" "C-M-S"))
                (?\] "XK_bracketright" ("C" "C-M"))
                (?\( "XK_parenleft"    ("C-S" "C-M-S"))
                (?\) "XK_parenright"   ("C-S" "C-M-S"))
                (?C  "XK_C"            ("C-S" "C-M-S"))
                (?X  "XK_X"            ("C-S" "C-M-S"))
                (?V  "XK_V"            ("C-S" "C-M-S"))
                (?I  "XK_I"            ("C-S" "C-M-S"))
                (?M  "XK_M"            ("C-S" "C-M-S"))
                (?J  "XK_J"            ("C-S" "C-M-S"))
                (?K  "XK_K"            ("C-S" "C-M-S"))
                (?m  "XK_m"            ("C" "C-M")               (([C-m]) ([C-M-m])))
                (?i  "XK_i"            ("C" "C-M")               (([C-i]) ([C-M-i])))
                (?O  "XK_O"            ("C-S" "C-M-S"))
                (? "XK_BackSpace"    ("C" "C-M" "M-S" "C-S" "C-M-S") (([C-]) ([C-M-]) ([M-S-]) ([C-S-]) ([C-M-S-])))
                (?+  "XK_plus"         ("C-S" "C-M-S"))
                (?-  "XK_minus"        ("C" "C-M"))
                ))
#+END_SRC

- The =C-m=, =C-M-m, =C-i= and =C-M-i= can be bind using symbol =[C-m]=, etc.
  They are not =C-m=, but =<C-m>= from Emacs perspective.
- It would be possible to map as well =C-j= but that is handy for inserting the
  new line literal (using =C-q=) for example for replace.

**** =C-<number>= and =C-M-<number>= keys

#+BEGIN_SRC emacs-lisp
(let ((nums '(1 2 3 4 5 6 7 8 9)))
  (mapc (lambda (x)
          ;; DEC 48 is '0' in ASCII table
          (let* ((code (+ 48 x))
                 (e (list code (format "XK_%d" x) (list "C" "C-M"))))
            (setq my-keys (append my-keys (list e)))))
        nums))
#+END_SRC

**** Auxiliary functions

#+BEGIN_SRC emacs-lisp
(defun flatten (list-of-lists)
  (apply #'append list-of-lists))

(defun join (sep lst)
   (mapconcat 'identity lst sep))

(defun zip (xs ys)
  (if (and (null xs) (null ys))
      ()
    (cons (cond
           ((null xs) (cons '(nil) (car ys)))
           ((null ys) (cons (car xs) '(nil)))
           (t (cons (car xs) (car ys))))
          (zip (cdr xs) (cdr ys)))))

(defun filter (condp lst)
  (delq nil
        (mapcar (lambda (x) (and (funcall condp x) x)) lst)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defconst my--my-keys-prefix "\033["
  "Escape code sequence prefix")

(defconst my--my-keys-suffix "u"
  "Escape code sequence suffix")

(defconst my--my-keys-modifiers
  '(("M"     . ("Mod1Mask"                           3))
    ("M-S"   . ("Mod1Mask | ShiftMask"               4))
    ("C"     . ("ControlMask"                        5))
    ("C-S"   . ("ControlMask | ShiftMask"            6))
    ("C-M"   . ("ControlMask | Mod1Mask"             7))
    ("C-M-S" . ("ControlMask | Mod1Mask | ShiftMask" 8)))
  "The key modifiers as triplets of st emacs name, st name and code")

(defun my--encode-key-mod (key-code mod-code)
  (format "%s%d;%d%s" my--my-keys-prefix key-code mod-code my--my-keys-suffix))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my--iterate-keys (fun)
  (mapcan
   (lambda (key)
     (let ((key-code (car key))
           (key-sym (cadr key))
           (mods (caddr key))
           (keys-emacs (cadddr key)))
       (mapcar
        (lambda (x)
          (let* ((mod (car x))
                 (key-emacs (cadr x))
                 (mod-info (cdr (assoc mod my--my-keys-modifiers))))
            (funcall fun key-code key-sym mod mod-info key-emacs)))
        (zip mods keys-emacs))))
   my-keys))
#+END_SRC

**** Enabling my-keys in st

#+BEGIN_SRC emacs-lisp
(defun my--escape-string (s)
  (mapconcat
   (lambda (x)
     (if (and (>= x 32) (<= x 255))
         (format "%c" x)
       (format "\\x%02X" x)))
   (append s nil)
   ""))

(defun my--st-encode-keys ()
  (delete-dups
   (my--iterate-keys
    (lambda (key-code key-sym mod mod-info key-emacs)
      (let ((mod-sym (car mod-info))
            (mod-code (cadr mod-info)))
        (format "{%s, %s, \"%s\", 0, 0}"
                key-sym
                mod-sym
                (my--escape-string (my--encode-key-mod key-code mod-code))))))))

(defun my--st-encode-mapped-keys ()
  (delete-dups
   (my--iterate-keys
    (lambda (key-code key-sym mod mod-info key-emacs)
      (format "%s" key-sym)))))

(defun my-st-sync-mapped-keys ()
  (interactive)
  (with-temp-buffer
    (insert (concat (join ",\n" (my--st-encode-keys)) ",\n"))
    (write-region (point-min) (point-max) (expand-file-name "my-keys.h" my-st-dir)))

  (with-temp-buffer
    (insert (concat (join ",\n" (my--st-encode-mapped-keys)) ",\n"))
    (write-region (point-min) (point-max) (expand-file-name "my-mapped-keys.h" my-st-dir))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(my-st-sync-mapped-keys)
#+END_SRC

**** Enabling my-keys in Emacs

Make Emacs aware of these new keys using the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Translation-Keymaps.html][input-decode-map]].

#+BEGIN_SRC emacs-lisp
(defun my-emacs-encode-keys ()
  (my--iterate-keys
   (lambda (key-code key-sym mod mod-info key-emacs)
     (let* ((mod-code (cadr mod-info))
            (input (my--encode-key-mod key-code mod-code))
            (key (if (null key-emacs)
                     (kbd (format "%s-%c" mod key-code))
                   key-emacs)))
       (when my-keys-debug
         (message "binding: %s to %s (%s-%c)" input key mod key-code))

       ;(define-key input-decode-map input key)
       (define-key xterm-function-map input key)))))

(when my-keys
  (message "Enabling my-keys")
  (eval-after-load "xterm" '(my-emacs-encode-keys)))
;;(unless (display-graphic-p)
;;  (my-emacs-encode-keys))
#+END_SRC

**** TODO should this go the the xterm-function-map instead?
- try it in GUI to see what works better
- try it in Xterm
- try term keys
* Config

#+BEGIN_SRC emacs-lisp
(add-to-list 'initial-frame-alist '(fullscreen . maximized))

(setq display-line-numbers-type t
      deft-directory (expand-file-name "~/Notes")
      deft-recursive t
      doom-localleader-key ","
      doom-localleader-alt-key "C-M-,"
      doom-font (font-spec :family "DejaVu Sans Mono for Powerline" :size 18)
      doom-big-font (font-spec :family "DejaVu Sans Mono for Powerline" :size 24)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 24)
      doom-theme 'doom-one
      evil-want-fine-undo t
      evil-cross-lines t
      org-directory (expand-file-name "~/Notes")    ; must be set before org is loaded
      undo-limit (* 100 1024 1024)
      user-full-name "Filip Krikava"
      user-mail-address "krikava@gmail.com"
      visual-order-cursor-movement t)

(setq-default evil-shift-width 2
              tab-width 2)

(after! agda2
  (set-lookup-handlers! 'agda2-mode
    :definition #'agda2-goto-definition-keyboard)

  (add-to-list 'auto-mode-alist '("\\.lagda.md\\'" . agda2-mode))

  (map! :after agda2-mode
        :map agda2-mode-map
        :i [left] #'evil-backward-char
        :localleader
        (:prefix "g"
          "G" nil
          "b" #'agda2-go-back
          "d" #'agda2-goto-definition-keyboard)))

(after! tex
  (setq TeX-save-query nil
        TeX-PDF-mode t
        TeX-show-compilation nil)
  (map! :map TeX-mode-map
        :in "C-c C-c" #'TeX-command-run-all
        :in "C-c C-a" #'TeX-command-master
        :localleader
        "b" #'TeX-command-run-all
        "m" #'TeX-command-master))

(after! avy
  (setq avy-all-windows t))

(after! comint
  (map! :map comint-mode-map
        :i [up] #'comint-previous-matching-input-from-input
        :i [down] #'comint-next-matching-input-from-input
        :i "C-k" #'kill-line
        :i "C-l" #'comint-clear-buffer)

  (setq comint-prompt-read-only t
        comint-scroll-to-bottom-on-output 'others
        comint-scroll-show-maximum-output t
        comint-move-point-for-matching-input 'end-of-line
        comint-scroll-to-bottom-on-input 'this))

(after! company
  (setq company-box-doc-enable nil
        company-minimum-prefix-length 4
        company-show-numbers t
        company-selection-wrap-around t))

(after! dash
  (dash-enable-font-lock))

(after! doom-modeline
  (setq doom-modeline-modal-icon nil)

  (doom-modeline-def-modeline 'main
    '(bar window-number modals matches buffer-info remote-host buffer-position selection-info)
    '(objed-state misc-info persp-name irc mu4e github debug input-method buffer-encoding lsp major-mode process vcs checker))

  (doom-modeline-def-modeline 'special
    '(bar window-number modals matches buffer-info-simple buffer-position selection-info)
    '(objed-state misc-info persp-name debug input-method irc-buffers buffer-encoding lsp major-mode process checker))

  (doom-modeline-def-modeline 'project
    '(bar window-number modals buffer-default-directory)
    '(misc-info mu4e github debug battery " " major-mode process)))

(after! ediff
  ;; from https://emacs.stackexchange.com/a/21460/26020
  ;; Check for org mode and existence of buffer
  (defun f-ediff-org-showhide (buf command &rest cmdargs)
    "If buffer exists and is orgmode then execute command"
    (when buf
      (when (eq (buffer-local-value 'major-mode (get-buffer buf)) 'org-mode)
        (save-excursion (set-buffer buf) (apply command cmdargs)))))

  (defun f-ediff-org-unfold-tree-element ()
    "Unfold tree at diff location"
    (f-ediff-org-showhide ediff-buffer-A 'org-reveal)
    (f-ediff-org-showhide ediff-buffer-B 'org-reveal)
    (f-ediff-org-showhide ediff-buffer-C 'org-reveal))

  (defun f-ediff-org-fold-tree ()
    "Fold tree back to top level"
    (f-ediff-org-showhide ediff-buffer-A 'hide-sublevels 1)
    (f-ediff-org-showhide ediff-buffer-B 'hide-sublevels 1)
    (f-ediff-org-showhide ediff-buffer-C 'hide-sublevels 1))

  (add-hook 'ediff-select-hook 'f-ediff-org-unfold-tree-element)
  (add-hook 'ediff-unselect-hook 'f-ediff-org-fold-tree))

(after! ess
  (setq ess-default-style 'RStudio
        ess-indent-level 4
        ess-nuke-trailing-whitespace-p t
        ess-tab-complete-in-script t
        ess-build-tags-command "system(\"~/bin/rtags.R '%s' '%s'\")"
        ess-indent-with-fancy-comments nil
        ess-R-argument-suffix "="
        ess-smart-S-assign-key nil
        ess-R-font-lock-keywords
        '((ess-R-fl-keyword:fun-defs . t)
          (ess-R-fl-keyword:modifiers . t)
          (ess-R-fl-keyword:keywords . t)
          (ess-R-fl-keyword:assign-ops . t)
          (ess-R-fl-keyword:constants . t)
          (ess-R-fl-keyword:F&T . t)
          (ess-fl-keyword:fun-calls . t)
          (ess-fl-keyword:numbers . t)
          (ess-fl-keyword:operators)
          (ess-fl-keyword:delimiters)
          (ess-fl-keyword:=)))

  (defun my-run-ess-R-debug ()
    (interactive)
    (let ((inferior-R-program-name "~/Research/Projects/R/R/R-3.6.2-dbg/bin/R"))
      (R)))

  ;; fix buffer in ready only mode, see https://github.com/emacs-ess/ESS/issues/300
  (add-hook 'inferior-ess-mode-hook
            (lambda ()
              (setq-local comint-use-prompt-regexp nil)
              (setq-local inhibit-field-text-motion nil)))

  (map! :localleader
        :map ess-mode-map
        "TAB"     #'ess-switch-to-inferior-or-script-buffer
        [backtab] #'ess-switch-process)

  (map! :map inferior-ess-mode-map
        :i [up] #'comint-previous-matching-input-from-input
        :i [down] #'comint-next-matching-input-from-input
        :localleader
        "TAB"     #'ess-switch-to-inferior-or-script-buffer))

(after! evil
  ;; this makes the Y/P work the same as in vim
  (evil-put-command-property 'evil-yank-line :motion 'evil-line))

(after! flycheck
  (setq flycheck-lintr-linters "with_defaults(infix_spaces_linter=NULL, line_length_linter=NULL)"))

(after! flyspell
  (map! :map flyspell-mouse-map
        "RET"     nil
        [return]  nil
        :n "RET"     #'flyspell-correct-at-point
        :n [return]  #'flyspell-correct-at-point))

(after! ivy
  (defun my--ivy-is-directory-p ()
    (and
     (> ivy--length 0)
     (not (string= (ivy-state-current ivy-last) "./"))
     (not (null (ivy-expand-file-if-directory (ivy-state-current ivy-last))))))

  (defun my--ivy-enter-directory-or-insert ()
    (interactive)
    (if (my--ivy-is-directory-p)
        (counsel-down-directory)
      (progn
        (let ((last-input (ivy--input)))
          (ivy-insert-current)
          (when (string= last-input (ivy--input))
            (ivy-call))))))

  (defun my--ivy-other-window-action (file-name)
    "Opens the current candidate in another window."
    (select-window
     (with-ivy-window
       (find-file-other-window (expand-file-name file-name (ivy-state-directory ivy-last)))
       (selected-window))))

  (defun my--ivy-dispatching-done ()
    (interactive)
    (let ((ivy-read-action-function 'ivy-read-action-ivy))
      (ivy-dispatching-done)))

  ;; M-o show action list
  ;; C-' ivy-avy
  ;; C-M-m ivy-call - does the action, but does not exit ivy
  ;; C-M-o like M-o but does not quit
  ;; C-M-n/p cobines C-n/p and C-M-m
  (map! :map ivy-minibuffer-map
        "C-j" #'ivy-alt-done ; has to be explicit because of evil
        "C-z" #'my--ivy-dispatching-done
        "C-w" #'ivy-yank-word
        "C-'" #'ivy-avy
        "<left>" #'counsel-up-directory
        "<backtab>" #'counsel-up-directory
        "<right>" #'my--ivy-enter-directory-or-insert
        "TAB" #'my--ivy-enter-directory-or-insert)

  (setq ivy-action-wrap t
        ivy-count-format "(%d/%d) "
        ivy-use-virtual-buffers t)

  (mapc
   (lambda (cmd)
     (ivy-add-actions
      cmd
      '(("O" my--ivy-other-window-action "open in other window"))))
   '(counsel-find-file counsel-recentf counsel-fzf counsel-dired doom/find-file-in-private-config))

  (minibuffer-depth-indicate-mode 1))

(after! magit
  (defconst my-dotfiles-git-dir (expand-file-name "~/.dotfiles"))

  (defun my--dotfiles-remove-magit-config (&optional kill)
    (setq magit-git-global-arguments
          (remove (format "--work-tree=%s" (getenv "HOME")) magit-git-global-arguments))
    (setq magit-git-global-arguments
          (remove (format "--git-dir=%s" my-dotfiles-git-dir) magit-git-global-arguments))
    (advice-remove 'magit-mode-bury-buffer #'my--dotfiles-remove-magit-config))

  ;; TODO make this work even if magit has not been loaded yet
  (defun my-dotfiles-magit ()
    (interactive)
    (when (and (boundp 'magit-git-global-arguments)
               (file-exists-p my-dotfiles-git-dir))
      (let ((home (getenv "HOME")))
        (add-to-list 'magit-git-global-arguments
                     (format "--work-tree=%s" home))
        (add-to-list 'magit-git-global-arguments
                     (format "--git-dir=%s" my-dotfiles-git-dir))
        (advice-add 'magit-mode-bury-buffer :after #'my--dotfiles-remove-magit-config)
        (magit-status-setup-buffer home)))))

(after! evil-nerd-commenter
  (map!
   :g "M-;" #'evilnc-comment-or-uncomment-lines))

(after! ob-tmux
  (setq org-babel-tmux-session-prefix "ob-"
        org-babel-tmux-terminal "st"
        org-babel-tmux-terminal-opts '("-T" "ob-tmux" "-e"))
  (add-to-list 'org-babel-load-languages '(tmux . t)))

(after! org
  (setq org-agenda-files '("~/Notes/Journal")
        org-blank-before-new-entry '((heading . nil) (plain-list-item . nil))
        org-capture-templates
        '(("t" "Todo"
           entry (file+headline "~/Notes/Journal/TODO.org" "INBOX")  "* TODO %?\ncaptured on: %U\nfrom: %a\n%i")
          ("n" "Note"
           entry (file+headline "~/Notes/Journal/Notes.org" "Notes") "* %?\ncaptured on: %U\nfrom: %a\n%i"))
        org-catch-invisible-edits 'smart
        org-confirm-babel-evaluate nil
        org-cycle-separator-lines 1
        org-ellipsis " ․․․"
        org-hide-emphasis-markers t
        org-id-link-to-org-use-id 'create-if-interactive
        org-image-actual-width nil
        org-imenu-depth 8
        org-latex-prefer-user-labels t
        org-log-done t
        org-log-done-with-time nil
        org-log-into-drawer t
        org-log-reschedule 'time
        org-refile-active-region-within-subtree t
        org-refile-allow-creating-parent-nodes 'confirm
        org-refile-targets '((nil :maxlevel . 6) (org-agenda-files :maxlevel . 7))
        org-refile-use-cache nil
        org-refile-use-outline-path 'file
        org-src-fontify-natively t
        org-src-preserve-indentation t
        org-src-tab-acts-natively t
        org-startup-with-inline-images t
        org-startup-indented t
        org-special-ctrl-a/e t
        org-superstar-headline-bullets-list '("⁖")
        org-show-context-detail '((agenda . local)
                                  (bookmark-jump . lineage)
                                  (isearch . tree) ; I want to see more info when looking at tree
                                  (default . ancestors))
        org-todo-keywords '((sequence "TODO(t)" "WAIT(w)" "NEXT(n)" "|" "DONE(d!)" "CANCELED(c@)")))

  (defun my-org-show-current-heading-tidily ()
    (interactive)
    "Show next entry, keeping other entries closed."
    (if (save-excursion (end-of-line) (outline-invisible-p))
        (progn (org-show-entry) (show-children))
      (outline-back-to-heading)
      (unless (and (bolp) (org-on-heading-p))
        (org-up-heading-safe)
        (hide-subtree)
        (error "Boundary reached"))
      (org-overview)
      (org-reveal t)
      (org-show-entry)
      (show-children)))

  (defun my-org-babel-remove-result-buffer ()
    "Remove results from every code block in buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
        (org-babel-remove-result))))

  (defadvice org-archive-subtree (around my-org-archive-subtree activate)
    "Archives all items under the current heading"
    (let ((org-archive-location
           (if (save-excursion (org-back-to-heading)
                               (> (org-outline-level) 1))
               ((concat ) (car (split-string (or )g-archive-location "::"))
                "::* "
                (car (org-get-outline-path)))
             org-archive-location)))
      ad-do-it))

  (map! :map org-mode-map
        :localleader
        "d" nil
        (:prefix ("j" . "journal")
          "j" #'org-journal-new-entry
          "s" #'org-journal-search-forever)
        (:prefix ("d" . "dates")
          "e" #'org-evaluate-time-range
          "d" #'org-deadline
          "s" #'org-schedule
          "t" #'org-time-stamp
          "T" #'org-time-stamp-inactive)))
#+END_SRC

#+RESULTS:

** Configuring bibliography management

#+BEGIN_SRC emacs-lisp
(setq my-bibliography-files '("~/Sync/Papers/references.bib"))
(setq my-bibliography-artifacts '("~/Sync/Papers/Artifacts"))
(setq my-bibliography-notes "~/Sync/Notes/Journal/Bibliography.org")
(setq my-bibliography-readling-list "~/Sync/Notes/Journal/Readings.org")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-find-file-external (fpath)
  (call-process shell-file-name nil
                nil nil
                shell-command-switch
                (format "%s %s"
                        (if (eq system-type 'darwin)
                            "open"
                          "xdg-open")
                        (shell-quote-argument fpath))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! ivy-bibtex

  (setq bibtex-completion-pdf-open-function
        (lambda (fpath)
          (if (string= (file-name-extension fpath) "pdf")
              (find-file fpath)
            (my-find-file-external fpath))))

  (defun my-bibtex-completion-open-pdf-external (keys &optional fallback-action)
    (let ((bibtex-completion-pdf-open-function 'my-find-file-external))
      (bibtex-completion-open-pdf keys fallback-action)))

  ;; from: https://github.com/org-roam/org-roam-bibtex
  (defun orb-process-file-field (citekey)
    "Process the 'file' BibTeX field and resolve if there are multiples.
     Search the disk for the document associated with this BibTeX
     entry.  The disk matching is based on looking in the
     `bibtex-completion-library-path' for a file with the
     CITEKEY.
     \(Mendeley, Zotero, normal paths) are all supported.  If there
     are multiple files found the user is prompted to select which one
     to enter"
    (let* ((entry (bibtex-completion-get-entry citekey))
           (paths (bibtex-completion-find-pdf entry)))
      (if (= (length paths) 1)
          (car paths)
        (completing-read "File to use: " paths))))

  (ivy-bibtex-ivify-action my-bibtex-completion-open-pdf-external my-ivy-bibtex-open-pdf-external)

  (ivy-add-actions
   'ivy-bibtex
   '(("E" my-ivy-bibtex-open-pdf-external "Open file in external viewer")
     ("c" ivy-bibtex-insert-citation "Insert citation")
     ("r" ivy-bibtex-insert-reference "Insert reference")))

  (setq bibtex-completion-bibliography my-bibliography-files
        bibtex-completion-library-path my-bibliography-artifacts
        bibtex-completion-notes-path my-bibliography-notes
        bibtex-completion-notes-template-one-file (concat
                                                   "\n"
                                                   "* ${author-or-editor} (${year}): ${title}\n"
                                                   "  :PROPERTIES:\n"
                                                   "  :Custom_ID: ${=key=}\n"
                                                   "  :NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n"
                                                   "  :URL: ${url}"
                                                   "  :DOI: ${doi}\n"
                                                   "  :END:\n\n"))
(add-to-list 'ivy-height-alist `(ivy-bibtex . ,(length (plist-get ivy--actions-list 'ivy-bibtex)))))
#+END_SRC

#+RESULTS:
: ((ivy-bibtex . 13) (counsel-evil-registers . 5) (counsel-yank-pop . 5) (counsel-git-log . 4))

Other files than PDF have to specify the file in the =file= field of the bibtex
entry.

#+BEGIN_SRC emacs-lisp
(after! org-noter
  (setq org-noter-default-notes-file-names `(,my-bibliography-notes)))
#+END_SRC

Based on the draft of the [[https://github.com/hlissner/doom-emacs/blob/5bc10f8b75a8d08ad37eb3cff15347b46d0427e6/modules/tools/biblio/config.el][biblio doom module]]
** TODO org-ref-cite-keymap
#+BEGIN_SRC emacs-lisp
(use-package! org-ref
  :when (featurep! :lang org)
  :after org
  :preface
  ;; This need to be set before the package is loaded, because org-ref will
  ;; automatically `require' an associated package during its loading.
  (setq org-ref-completion-library (cond ((featurep! :completion ivy)  #'org-ref-ivy-cite)
                                         ((featurep! :completion helm) #'org-ref-helm-bibtex)
                                         (t                            #'org-ref-reftex)))
  :custom
  (org-ref-bibliography-notes my-bibliography-notes)
  (org-ref-bibliography-files my-bibliography-files)
  (org-ref-default-bibliography my-bibliography-files)
  (org-ref-pdf-directory (car my-bibliography-artifacts))
  (reftex-default-bibliography org-ref-default-bibliography)
  ;; Although the name is helm-bibtex, it is actually a bibtex-completion function
  ;; it is the legacy naming of the project helm-bibtex that causes confusion.
  (org-ref-open-pdf-function 'org-ref-get-pdf-filename-helm-bibtex)
  (org-ref-notes-function #'org-ref-notes-function-one-file))
#+END_SRC

** Rest of the config
#+BEGIN_SRC emacs-lisp
(after! org-journal
  ;; from https://github.com/bastibe/org-journal#journal-capture-template
  (defun org-journal-find-location ()
    ;; Open today's journal, but specify a non-nil prefix argument in order to
    ;; inhibit inserting the heading; org-capture will insert the heading.
    (org-journal-new-entry t)
    ;; Position point on the journal's top-level heading so that org-capture
    ;; will add the new entry as a child entry.
    (goto-char (point-min)))
  (setq org-journal-date-format "%A, %B %d %Y"
        org-journal-file-format "Journal-%Y.org"
        org-journal-dir "~/Sync/Notes/Journal/"
        org-journal-file-type 'yearly)
  (add-to-list 'org-capture-templates
               '("j" "Journal" entry (function org-journal-find-location)
                  "** %(format-time-string org-journal-time-format)%?")))

(after! rustic
    (setq lsp-rust-server 'rust-analyzer
          rustic-lsp-server 'rust-analyzer))

(after! projectile
  (mapc (lambda (x)
          (when (file-directory-p x)
            (add-to-list 'projectile-project-search-path x)))
        '("~/Projects" "~/Research/Projects" "~/Research/Publications")))

(after! evil-org
  (map! :map evil-org-mode-map
        :i "C-h" nil
        :i "C-j" nil
        :i "C-k" #'org-kill-line
        :i "C-l" nil))

(after! yasnippet
  (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets"))

(after! web-mode
  (add-hook 'web-mode-hook #'flycheck-mode)

  (setq web-mode-markup-indent-offset 2  ; Indentation
        web-mode-code-indent-offset 2
        web-mode-enable-auto-quoting nil ; disbale adding "" after an =
        web-mode-auto-close-style 2))

(after! which-key
  (setq which-key-idle-delay .6))

(after! winum
  (setq winum-scope 'frame-local))

;; -----------------------------------------------------------------------------
;; Definitions of my packages
;; -----------------------------------------------------------------------------

(use-package! flyspell-correct-ivy
  :after (flyspell ivy)
  :commands (flyspell-correct-wrapper)
  :init
  (setq flyspell-correct-interface #'flyspell-correct-ivy)
  :bind
  (:map flyspell-mode-map
    ("M-'" . flyspell-correct-wrapper)))

;; -----------------------------------------------------------------------------
;; My functions
;; -----------------------------------------------------------------------------

(defun my-save-buffer-and-switch-to-normal-mode ()
  (interactive)
  (save-buffer)
  (evil-force-normal-state))

(defun my-kill-buffer-and-window ()
  (interactive)
  (if (> (count-windows) 1)
      (kill-buffer-and-window)
    (kill-buffer)))

(defun my-switch-to-messages-buffer (&optional arg)
    "Switch to the `*Messages*' buffer. If prefix argument ARG is
given, switch to it in an other, possibly new window."
    (interactive "P")
    (with-current-buffer (messages-buffer)
      (goto-char (point-max))
      (if arg
          (switch-to-buffer-other-window (current-buffer))
        (switch-to-buffer (current-buffer)))))

(defun my-copy-to-xclipboard ()
  (interactive)
  (if (use-region-p)
      (if (not (display-graphic-p))
          (letrec ((s (buffer-substring-no-properties (region-beginning) (region-end)))
                   (s-length (+ (* (length s) 3) 2)))
            (if (<= s-length 16384) ; magic number set to the same as ESC_BUF_SIZ of suckless termial (st.c)
                (progn
                  (send-string-to-terminal (concat "\e]52;c;"
                                                   (base64-encode-string (encode-coding-string s 'utf-8) t)
                                                   "\07"))
                  (message "Yanked region to terminal clipboard")
                  (deactivate-mark))
              (message "Selection too long (%d) to send to terminal." s-length)))
        (if (= 0 (shell-command-on-region (region-beginning) (region-end) "xsel -i -b"))
            (message "Yanked region to X-clipboard")
          (error "Is program `xsel' installed?")))
    (message "Nothing to yank to terminal clipboard")))

(defun my-cut-to-xclipboard ()
  (interactive)
  (my-copy-to-xclipboard)
  (kill-region (region-beginning) (region-end)))

(defun my-paste-from-xclipboard ()
  "Uses shell command `xsel -o' to paste from x-clipboard. With
one prefix arg, pastes from X-PRIMARY, and with two prefix args,
pastes from X-SECONDARY."
  (interactive)
  (if (display-graphic-p)
      (clipboard-yank)
    (letrec
        ((opt (prefix-numeric-value current-prefix-arg))
         (opt (cond
               ((=  1 opt) "b")
               ((=  4 opt) "p")
               ((= 16 opt) "s"))))
(insert (shell-command-to-string (concat "xsel -o -" opt))))))

(use-package! org-mru-clock
  :after org
  :commands (org-mru-clock-in org-mru-clock-select-recent-task)
  :custom
  (org-mru-clock-how-many 100)
  (org-mru-clock-completing-read #'ivy-completing-read)
  (org-mru-clock-keep-formatting t))

(use-package! super-save
  :unless noninteractive
  :custom
  (super-save-auto-save-when-idle t)
  (super-save-idle-duration 30)
  :config
  ;; add integration with ace-window
  (add-to-list 'super-save-triggers 'ace-window)
  (add-to-list 'super-save-triggers 'winum-select-window-by-number)
  (add-to-list 'super-save-hook-triggers 'find-file-hook)
  (super-save-mode 1))

;; ----------------------------------------------------------------------------
;; EMAIL
;; ----------------------------------------------------------------------------
(set-email-account! "krikava@gmail.com"
                    '((mu4e-maildir           . "~/Mail/krikava@gmail.com")
                      (mu4e-attachment-dir    . "~/Downloads")
                      (mu4e-get-mail-command  . "mbsync gmail-inbox")
                      (mu4e-sent-folder       . "/sent")
                      (mu4e-drafts-folder     . "/drafts")
                      (mu4e-trash-folder      . "/trash")
                      (mu4e-refile-folder     . "/all")
                      (mu4e-compose-signature . "/cheers\nFilip"))
                    t)

(after! mu4e
  (setq message-kill-buffer-on-exit t
        message-sendmail-extra-arguments '("--read-envelope-from")
        message-send-mail-function 'message-send-mail-with-sendmail
        message-sendmail-f-is-evil t
        mu4e-change-filenames-when-moving t
        mu4e-compose-complete-only-personal t
        mu4e-headers-skip-duplicates t
        mu4e-headers-include-related t
        mu4e-user-mail-address-list '("krikava@gmail.com" "filip.krikava@fit.cvut.cz")
        mu4e-view-auto-mark-as-read nil))

(after! org-mu4e
  (setq org-mu4e-convert-to-html nil))

;; ----------------------------------------------------------------------------
;; GLOBAL MAP
;; ----------------------------------------------------------------------------

(map!
 :n "C-h" nil
 :i "C-x C-s"  #'my-save-buffer-and-switch-to-normal-mode
 :i "C-x s" #'company-yasnippet
 :g "C-s"   #'swiper-isearch
 :i "C-k"   #'kill-visual-line
 :g "C-S-X" #'my-cut-to-xclipboard
 :g "C-S-C" #'my-copy-to-xclipboard
 :i "C-d"   #'evil-delete-char
 :g "M-u"   #'universal-argument
 (:when (display-graphic-p)
  ; The paste shortcut (=C-S-V=) we only want in GUI. When running in terminal it
  ; is better to use the terminal paste since it will be a [[https://cirw.in/blog/bracketed-paste][bracketed paste]].
  :g "C-S-V" #'my-paste-from-xclipboard)
 :n "M-y"   #'counsel-yank-pop
 :g "M-1"   #'winum-select-window-1
 :g "M-2"   #'winum-select-window-2
 :g "M-3"   #'winum-select-window-3
 :g "M-4"   #'winum-select-window-4
 :g "M-5"   #'winum-select-window-5
 :g "M-6"   #'winum-select-window-6
 :g "M-7"   #'winum-select-window-7
 :g "M-8"   #'winum-select-window-8
 :g "M-9"   #'winum-select-window-9
 :g "M-0"   #'winum-select-window-0
 (:when (featurep! :ui workspaces)
   :g "C-1"   #'+workspace/switch-to-0
   :g "C-2"   #'+workspace/switch-to-1
   :g "C-3"   #'+workspace/switch-to-2
   :g "C-4"   #'+workspace/switch-to-3
   :g "C-5"   #'+workspace/switch-to-4
   :g "C-6"   #'+workspace/switch-to-5
   :g "C-7"   #'+workspace/switch-to-6
   :g "C-8"   #'+workspace/switch-to-7
   :g "C-9"   #'+workspace/switch-to-8
   :g "C-0"   #'+workspace/switch-to-final))

;; ----------------------------------------------------------------------------
;; LEADER MAP
;; ----------------------------------------------------------------------------

(map! :leader
      "X" nil
      :desc "Capture" "C" #'org-capture
      :desc "Time clock" "T" #'org-mru-clock-in
      :desc "Recent clocks" "R" #'org-mru-clock-select-recent-task
      :desc "Journal entry" "J" #'org-journal-new-entry
      (:prefix ("n" . "notes")
        :desc "Org ref" "r" #'org-ref
        :desc "Bibliography" "b" #'helm-bibtex)
      (:prefix ("w" . "window")
        ;; the following are mapped to moving to window function
        ;; these are no needed as they are already mapped to C-w h / leader h
        ;; plus C-h is useful to see the rest of the mapping in which-key
        "C-h" nil
        "C-j" nil  ; ""
        "C-k" nil  ; ""
        "C-l" nil) ; ""
      (:prefix ("b" . "buffer")
        :desc "Switch to message buffer" "M"  #'my-switch-to-messages-buffer
        :desc "Kill buffer and window" "d" #'my-kill-buffer-and-window)
      (:prefix ("g". "git")
        :desc "My dotfiles status" "M" #'my-dotfiles-magit)
      (:prefix ("t" . "toggle")
        :desc "Auto-fill mode" "W" #'auto-fill-mode))

;; ;; Here are some additional functions/macros that could help you configure Doom:
;; ;;
;; ;; - `load!' for loading external *.el files relative to this one
;; ;; - `use-package' for configuring packages
;; ;; - `after!' for running code after a package has loaded
;; ;; - `add-load-path!' for adding directories to the `load-path', where Emacs
;; ;;   looks when you load packages with `require' or `use-package'.
;; ;; - `map!' for binding new keys
;; ;;
;; ;; To get information about any of these functions/macros, move the cursor over
;; ;; the highlighted symbol at press 'K' (non-evil users must press 'C-c g k').
;; ;; This will open documentation for it, including demos of how they are used.
;; ;;
#+END_SRC

** Setup printing

#+BEGIN_SRC emacs-lisp
(setq pdf-misc-print-programm "/usr/bin/lpr"
      pdf-misc-print-programm-args '("-o media=A4" "-o sides=two-sided-long-edge"))
#+END_SRC
** TMUX environment refresh

#+BEGIN_SRC emacs-lisp
(defun my-refresh-env ()
  (interactive)
  (let ((tmux-update-envir
         (split-string-and-unquote
          (shell-command-to-string "tmux show-options -gv update-environment") "[\n]"))
        (tmux-envir-string
         (split-string-and-unquote
          (shell-command-to-string "tmux show-environment") "[\n]"))
        (tmux-envir
         (mapcar (lambda (x) (split-string x "[=]")) tmux-envir-string))
        (update-vars (delq nil (mapcar (lambda (x) (when (not (null (member (car x) tmux-update-envir))) x)) tmux-envir))))
    (mapc (lambda (x)
            (let ((name (car x))
                  (val (cadr x)))
              (message "Setting %s to '%s'" name val)
              (setenv name val)))
          update-vars)))

#+END_SRC

